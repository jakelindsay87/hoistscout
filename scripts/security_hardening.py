#!/usr/bin/env python3
"""
Security hardening script for HoistScraper.
Addresses critical security issues identified in the security audit.
"""

import os
import secrets
import string
import sys
from pathlib import Path
import json
import subprocess


def generate_secure_password(length=32):
    """Generate a cryptographically secure password."""
    alphabet = string.ascii_letters + string.digits + string.punctuation
    # Remove problematic characters for shell/env usage
    alphabet = alphabet.replace('"', '').replace("'", '').replace('\\', '')
    password = ''.join(secrets.choice(alphabet) for _ in range(length))
    return password


def generate_env_file():
    """Generate secure .env.production file with strong credentials."""
    env_template = """# HoistScraper Production Environment Configuration
# Generated by security_hardening.py
# NEVER commit this file to version control!

# Database Configuration
DB_USER=hoistscraper
DB_PASSWORD={db_password}
DB_NAME=hoistscraper
DATABASE_URL=postgresql://hoistscraper:{db_password}@hoistscraper-db:5432/hoistscraper

# Redis Configuration
REDIS_PASSWORD={redis_password}
REDIS_URL=redis://:{redis_password}@hoistscraper-redis:6379/0

# Security Configuration
CREDENTIAL_SALT={credential_salt}
CREDENTIAL_PASSPHRASE={credential_passphrase}
API_KEY={api_key}
REQUIRE_AUTH=true
REQUIRE_AUTH_FOR_INGEST=true

# Session Configuration
SESSION_SECRET={session_secret}
JWT_SECRET={jwt_secret}

# Environment
ENVIRONMENT=production
LOG_LEVEL=INFO
LOG_FORMAT=json

# Worker Configuration
WORKER_THREADS=4
CRAWL_CONCURRENCY=3
RATE_LIMIT_DELAY=2
OPPORTUNITIES_LIMIT=50

# Monitoring
SENTRY_DSN=
PROMETHEUS_ENABLED=true

# CORS Configuration (update with your domain)
ALLOWED_ORIGINS=https://yourdomain.com

# SSL Configuration
FORCE_HTTPS=true
HSTS_MAX_AGE=31536000

# Rate Limiting
RATE_LIMIT_PER_MINUTE=60
RATE_LIMIT_PER_HOUR=1000
"""

    # Generate secure values
    values = {
        'db_password': generate_secure_password(),
        'redis_password': generate_secure_password(),
        'credential_salt': secrets.token_hex(32),
        'credential_passphrase': generate_secure_password(48),
        'api_key': secrets.token_urlsafe(32),
        'session_secret': secrets.token_hex(32),
        'jwt_secret': secrets.token_hex(64),
    }
    
    env_content = env_template.format(**values)
    
    # Write to file with secure permissions
    env_file = Path('.env.production')
    env_file.write_text(env_content)
    os.chmod(env_file, 0o600)  # Read/write for owner only
    
    print(f"‚úÖ Generated {env_file} with secure credentials")
    print("‚ö†Ô∏è  IMPORTANT: Store these credentials securely and never commit to git!")
    
    # Create backup
    backup_file = Path('.env.production.backup')
    backup_file.write_text(env_content)
    os.chmod(backup_file, 0o600)
    print(f"üìÅ Backup saved to {backup_file}")
    
    return values


def update_docker_compose_secure():
    """Update docker-compose.secure.yml with security enhancements."""
    secure_compose = """version: '3.8'

services:
  # Nginx reverse proxy with SSL
  nginx:
    image: nginx:alpine
    container_name: hoistscraper-nginx
    ports:
      - "80:80"
      - "443:443"
    volumes:
      - ./nginx/nginx-ssl.conf:/etc/nginx/nginx.conf:ro
      - ./nginx/ssl:/etc/nginx/ssl:ro
      - ./nginx/dhparam.pem:/etc/nginx/dhparam.pem:ro
    depends_on:
      - backend
      - frontend
    networks:
      - app-network
    restart: unless-stopped
    
  redis:
    image: redis:7-alpine
    container_name: hoistscraper-redis
    # No external ports exposed
    volumes:
      - redis_data:/data
    networks:
      - app-network
    command: redis-server --requirepass ${REDIS_PASSWORD} --appendonly yes
    healthcheck:
      test: ["CMD", "redis-cli", "--pass", "${REDIS_PASSWORD}", "ping"]
      interval: 10s
      timeout: 5s
      retries: 3
    restart: unless-stopped

  db:
    image: postgres:16
    container_name: hoistscraper-db
    environment:
      POSTGRES_USER: ${DB_USER}
      POSTGRES_PASSWORD: ${DB_PASSWORD}
      POSTGRES_DB: ${DB_NAME}
      POSTGRES_INITDB_ARGS: "--auth-host=scram-sha-256 --auth-local=scram-sha-256"
    # No external ports exposed
    volumes:
      - postgres_data:/var/lib/postgresql/data
    networks:
      - app-network
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U ${DB_USER}"]
      interval: 10s
      timeout: 5s
      retries: 5
    restart: unless-stopped

  backend:
    build:
      context: ./backend
      dockerfile: Dockerfile
      target: production
    container_name: hoistscraper-backend
    env_file: .env.production
    depends_on:
      db:
        condition: service_healthy
      redis:
        condition: service_healthy
    # No external ports exposed - nginx handles traffic
    volumes:
      - scraper_data:/data:rw
      - ./logs/backend:/app/logs:rw
    networks:
      - app-network
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:8000/health"]
      interval: 30s
      timeout: 10s
      retries: 3
    restart: unless-stopped
    user: "1000:1000"  # Run as non-root user
    read_only: true    # Read-only root filesystem
    tmpfs:
      - /tmp
    security_opt:
      - no-new-privileges:true
    cap_drop:
      - ALL
    cap_add:
      - NET_BIND_SERVICE

  frontend:
    build:
      context: ./frontend
      dockerfile: Dockerfile
      target: runner
    container_name: hoistscraper-frontend
    env_file: .env.production
    depends_on:
      backend:
        condition: service_healthy
    # No external ports exposed - nginx handles traffic
    networks:
      - app-network
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:3000/api/health"]
      interval: 30s
      timeout: 10s
      retries: 3
    restart: unless-stopped
    user: "1000:1000"  # Run as non-root user
    read_only: true    # Read-only root filesystem
    tmpfs:
      - /tmp
      - /app/.next/cache
    security_opt:
      - no-new-privileges:true

  worker:
    build:
      context: ./backend
      dockerfile: Dockerfile.worker
    container_name: hoistscraper-worker
    env_file: .env.production
    depends_on:
      db:
        condition: service_healthy
      redis:
        condition: service_healthy
      ollama:
        condition: service_started
    volumes:
      - scraper_data:/data:rw
      - ./logs/worker:/app/logs:rw
    networks:
      - app-network
    restart: unless-stopped
    user: "1000:1000"  # Run as non-root user
    security_opt:
      - no-new-privileges:true
    cap_drop:
      - ALL

  ollama:
    image: ollama/ollama:latest
    container_name: hoistscraper-ollama
    # No external ports exposed
    volumes:
      - ollama_data:/root/.ollama
    networks:
      - app-network
    restart: unless-stopped
    environment:
      OLLAMA_HOST: 0.0.0.0
    security_opt:
      - no-new-privileges:true

volumes:
  postgres_data:
    driver: local
  redis_data:
    driver: local
  scraper_data:
    driver: local
  ollama_data:
    driver: local

networks:
  app-network:
    driver: bridge
    ipam:
      config:
        - subnet: 172.20.0.0/16
"""
    
    # Write secure docker-compose
    compose_file = Path('docker-compose.secure.yml')
    compose_file.write_text(secure_compose)
    print(f"‚úÖ Updated {compose_file} with security enhancements")


def create_nginx_ssl_config():
    """Create secure nginx configuration with SSL."""
    nginx_config = """user nginx;
worker_processes auto;
error_log /var/log/nginx/error.log warn;
pid /var/run/nginx.pid;

events {
    worker_connections 1024;
}

http {
    include /etc/nginx/mime.types;
    default_type application/octet-stream;

    # Security headers
    add_header X-Frame-Options "DENY" always;
    add_header X-Content-Type-Options "nosniff" always;
    add_header X-XSS-Protection "1; mode=block" always;
    add_header Referrer-Policy "strict-origin-when-cross-origin" always;
    add_header Strict-Transport-Security "max-age=31536000; includeSubDomains; preload" always;
    add_header Permissions-Policy "geolocation=(), microphone=(), camera=()" always;
    add_header Content-Security-Policy "default-src 'self'; script-src 'self' 'unsafe-inline' 'unsafe-eval'; style-src 'self' 'unsafe-inline'; img-src 'self' data: https:; font-src 'self'; connect-src 'self'; frame-ancestors 'none';" always;

    # Hide nginx version
    server_tokens off;

    # Logging
    log_format main '$remote_addr - $remote_user [$time_local] "$request" '
                    '$status $body_bytes_sent "$http_referer" '
                    '"$http_user_agent" "$http_x_forwarded_for"';
    access_log /var/log/nginx/access.log main;

    # SSL Configuration
    ssl_protocols TLSv1.2 TLSv1.3;
    ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES256-GCM-SHA384:ECDHE-ECDSA-AES256-GCM-SHA384:DHE-RSA-AES128-GCM-SHA256:DHE-DSS-AES128-GCM-SHA256:kEDH+AESGCM:ECDHE-RSA-AES128-SHA256:ECDHE-ECDSA-AES128-SHA256;
    ssl_prefer_server_ciphers on;
    ssl_dhparam /etc/nginx/dhparam.pem;
    ssl_session_cache shared:SSL:10m;
    ssl_session_timeout 10m;
    ssl_stapling on;
    ssl_stapling_verify on;

    # Rate limiting
    limit_req_zone $binary_remote_addr zone=api:10m rate=10r/s;
    limit_req_zone $binary_remote_addr zone=general:10m rate=30r/s;

    # Upstream definitions
    upstream backend {
        server backend:8000;
    }

    upstream frontend {
        server frontend:3000;
    }

    # Redirect HTTP to HTTPS
    server {
        listen 80;
        server_name _;
        return 301 https://$server_name$request_uri;
    }

    # HTTPS server
    server {
        listen 443 ssl http2;
        server_name yourdomain.com;

        ssl_certificate /etc/nginx/ssl/cert.pem;
        ssl_certificate_key /etc/nginx/ssl/key.pem;

        # Security
        client_max_body_size 10M;
        client_body_timeout 12s;
        client_header_timeout 12s;

        # API endpoints
        location /api {
            limit_req zone=api burst=20 nodelay;
            
            proxy_pass http://backend;
            proxy_set_header Host $host;
            proxy_set_header X-Real-IP $remote_addr;
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
            proxy_set_header X-Forwarded-Proto $scheme;
            
            # Security headers for API
            proxy_hide_header X-Powered-By;
            proxy_hide_header Server;
        }

        # Frontend
        location / {
            limit_req zone=general burst=50 nodelay;
            
            proxy_pass http://frontend;
            proxy_set_header Host $host;
            proxy_set_header X-Real-IP $remote_addr;
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
            proxy_set_header X-Forwarded-Proto $scheme;
        }

        # Health check endpoint (no rate limiting)
        location /health {
            proxy_pass http://backend/health;
            access_log off;
        }
    }
}
"""
    
    # Create nginx directory
    nginx_dir = Path('nginx')
    nginx_dir.mkdir(exist_ok=True)
    
    # Write nginx config
    nginx_file = nginx_dir / 'nginx-ssl.conf'
    nginx_file.write_text(nginx_config)
    print(f"‚úÖ Created {nginx_file} with security headers and SSL configuration")
    
    # Create DH parameters script
    dhparam_script = """#!/bin/bash
# Generate DH parameters for nginx (this takes a while)
openssl dhparam -out nginx/dhparam.pem 2048
"""
    
    dhparam_file = Path('scripts/generate_dhparam.sh')
    dhparam_file.write_text(dhparam_script)
    os.chmod(dhparam_file, 0o755)
    print(f"‚úÖ Created {dhparam_file} - run this to generate DH parameters")


def update_api_auth_default():
    """Update API authentication to be required by default."""
    api_auth_file = Path('backend/hoistscraper/auth/api_auth.py')
    if api_auth_file.exists():
        content = api_auth_file.read_text()
        # Update REQUIRE_AUTH default to true
        updated_content = content.replace(
            'REQUIRE_AUTH = os.getenv("REQUIRE_AUTH", "false").lower() == "true"',
            'REQUIRE_AUTH = os.getenv("REQUIRE_AUTH", "true").lower() == "true"'
        )
        api_auth_file.write_text(updated_content)
        print("‚úÖ Updated API authentication to be required by default")


def create_security_checklist():
    """Create a security deployment checklist."""
    checklist = """# HoistScraper Security Deployment Checklist

## Pre-Deployment Security Tasks

### 1. Environment Configuration
- [ ] Generated .env.production with strong passwords
- [ ] Stored credentials in secure password manager
- [ ] Removed all hardcoded credentials from code
- [ ] Set REQUIRE_AUTH=true
- [ ] Configured ALLOWED_ORIGINS with actual domain

### 2. SSL/TLS Setup
- [ ] Obtained SSL certificate (Let's Encrypt or commercial)
- [ ] Generated DH parameters (2048-bit minimum)
- [ ] Configured nginx with SSL
- [ ] Tested SSL configuration (ssllabs.com)
- [ ] Enabled HSTS with preload

### 3. Dependency Updates
- [ ] Updated all Python dependencies: `cd backend && poetry update`
- [ ] Updated all Node.js dependencies: `cd frontend && npm update`
- [ ] Ran vulnerability scan: `cd backend && pip-audit`
- [ ] No critical vulnerabilities remain

### 4. Access Control
- [ ] Removed exposed database ports from docker-compose
- [ ] Configured firewall rules (ports 80/443 only)
- [ ] Set up API authentication for all endpoints
- [ ] Tested authentication is enforced

### 5. Monitoring Setup
- [ ] Configured Sentry DSN for error tracking
- [ ] Set up log aggregation
- [ ] Configured alerts for security events
- [ ] Set up uptime monitoring

### 6. Backup Configuration
- [ ] Set up automated database backups
- [ ] Tested backup restoration process
- [ ] Configured offsite backup storage
- [ ] Documented recovery procedures

### 7. Security Testing
- [ ] Ran OWASP ZAP scan
- [ ] Tested for SQL injection
- [ ] Tested for XSS vulnerabilities
- [ ] Verified rate limiting works
- [ ] Tested authentication bypass attempts

### 8. Documentation
- [ ] Documented all security configurations
- [ ] Created incident response plan
- [ ] Documented secret rotation procedure
- [ ] Created security contact list

## Deployment Steps

1. **Use secure Docker Compose**:
   ```bash
   docker-compose -f docker-compose.secure.yml --env-file .env.production up -d
   ```

2. **Verify services are running**:
   ```bash
   docker-compose -f docker-compose.secure.yml ps
   ```

3. **Check logs for errors**:
   ```bash
   docker-compose -f docker-compose.secure.yml logs
   ```

4. **Test authentication**:
   ```bash
   curl -H "Authorization: Bearer YOUR_API_KEY" https://yourdomain.com/api/websites
   ```

## Post-Deployment Security Tasks

- [ ] Remove default credentials
- [ ] Disable debug mode
- [ ] Set up security scanning in CI/CD
- [ ] Schedule security audit for 30 days
- [ ] Monitor logs for suspicious activity
- [ ] Test backup restoration

## Emergency Contacts

- Security Lead: ________________
- DevOps Lead: _________________
- Incident Response: ____________

## Notes

_Add any deployment-specific notes here_

---

Deployment Date: ________________
Deployed By: ____________________
Security Review: ________________
"""
    
    checklist_file = Path('SECURITY_DEPLOYMENT_CHECKLIST.md')
    checklist_file.write_text(checklist)
    print(f"‚úÖ Created {checklist_file}")


def main():
    """Run security hardening tasks."""
    print("üîí HoistScraper Security Hardening Script")
    print("=" * 50)
    
    # Check if we're in the right directory
    if not Path('docker-compose.yml').exists():
        print("‚ùå Error: Must run from HoistScraper root directory")
        sys.exit(1)
    
    # Create .gitignore entry for .env.production
    gitignore = Path('.gitignore')
    if gitignore.exists():
        content = gitignore.read_text()
        if '.env.production' not in content:
            with open(gitignore, 'a') as f:
                f.write('\n# Production secrets - NEVER commit!\n')
                f.write('.env.production\n')
                f.write('.env.production.backup\n')
            print("‚úÖ Added .env.production to .gitignore")
    
    # Run hardening tasks
    print("\nüìù Generating secure environment configuration...")
    credentials = generate_env_file()
    
    print("\nüê≥ Creating secure Docker Compose configuration...")
    update_docker_compose_secure()
    
    print("\nüîß Creating nginx SSL configuration...")
    create_nginx_ssl_config()
    
    print("\nüîê Updating API authentication defaults...")
    update_api_auth_default()
    
    print("\nüìã Creating security deployment checklist...")
    create_security_checklist()
    
    print("\n‚úÖ Security hardening complete!")
    print("\n‚ö†Ô∏è  IMPORTANT NEXT STEPS:")
    print("1. Store the generated credentials securely")
    print("2. Update ALLOWED_ORIGINS in .env.production with your domain")
    print("3. Generate SSL certificates for your domain")
    print("4. Run: ./scripts/generate_dhparam.sh")
    print("5. Review SECURITY_DEPLOYMENT_CHECKLIST.md")
    print("6. Deploy using: docker-compose -f docker-compose.secure.yml --env-file .env.production up -d")
    
    print("\nüîë Generated Credentials Summary:")
    print(f"   API Key: {credentials['api_key'][:8]}...")
    print(f"   JWT Secret: {credentials['jwt_secret'][:8]}...")
    print("   (Full credentials saved in .env.production)")


if __name__ == "__main__":
    main()